## 三 运算符和流程控制
[TOC]

### 1.运算符

`Scala 运算符的使用和 Java 运算符的使用基本相同，只有个别细节上不同`

> 还要强调一点的是 : 在Scala中,是一个安全面向对象的概念.
>
> <strong style="color:#c00000;">**因此,我们看到的所有的运算符,其实调用的本质都是对象调用方法的过程**</strong> 
>
> ```scala
> var r1: Int = 10 / 3  // 3
> //完整的写法如下,是通过10这个对象调用了./方法(3)
> var rq: Int = 10./ (3)
> println("r1=" + r1)
> ```
>
> 

#### 1.1 算术运算符

> **算术运算符指的就是`用来进行算术操作的符号`,  常用的有以下几种:** 

| 运算符 | 功能解释                                                     |
| :----- | ------------------------------------------------------------ |
| +      | 加号, 功能有3点.   1) 表示正数    2) 普通的加法操作    3) 字符串的拼接 |
| -      | 减号, 功能有2点.    1) 表示负数   2) 普通的减法操作          |
| *      | 乘号,  用于获取两个数据的乘积                                |
| /      | 除法,  用于获取两个数据的商                                  |
| %      | 取余(也叫取模),  用于获取两个数据的余数                      |

**注意:**

1. 对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分
2. 对一个数取模 a%b，和 Java 的取模规则一样

**案例:**

```scala
def main(args: Array[String]): Unit = {
    //（1）对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。
    var r1: Int = 10 / 3  // 3
    println("r1=" + r1)
    var r2: Double = 10 / 3 // 3.0
    println("r2=" + r2)
    var r3: Double = 10.0 / 3 // 3.3333
    println("r3=" + r3)
    println("r3=" + r3.formatted("%.2f")) // 含义：保留小数点 2位，使用四舍五入
    //（2）对一个数取模 a%b，和 Java 的取模规则一样。
    var r4 = 10 % 3 // 1
    println("r4=" + r4)
  }
```



#### 1.2 关系运算符（比较运算符）

> 关系运算符指的就是`用来进行比较操作的符号`.  例如: 数据是否相等, 是否不等, 数据1大还是数据2大...等这些操作.

| 运算符 | 功能解释                                       |
| ------ | ---------------------------------------------- |
| >      | 用来判断前边的数据`是否大于`后边的数据         |
| >=     | 用来判断前边的数据`是否大于或者等于`后边的数据 |
| <      | 用来判断前边的数据`是否小于`后边的数据         |
| <=     | 用来判断前边的数据`是否小于或者等于`后边的数据 |
| ==     | 用来判断两个数据`是否相等`                     |
| !=     | 用来判断两个数据`是否不等`                     |

**注意:**

1. 关系表达式不管简单还是复杂, 最终结果一定是Boolean类型的值, 要么是true, 要么是false.

2. <strong style="color:#ff0000;">**千万不要把==写成=, 否则结果可能不是你想要的.**</strong> 

3. Java 和 Scala 中关于==的区别

   | 需求描述           | Scala代码  | Java代码     |
   | ------------------ | ---------- | ------------ |
   | 比较数据值         | == 或者 != | equals()方法 |
   | 比较引用值(地址值) | eq方法     | == 或者 !=   |

   ```scala
   val s1 = "abc"
   val s2 = s1 + ""
   s1 == s2     //结果是: true,  因为比较的是 数据值
   s1.eq(s2)	 //结果是: false, 因为比较的是 地址值
   ```

   

**案例**

```scala
def main(args: Array[String]): Unit = {
    // 测试：>、>=、<=、<、==、!=
    var a: Int = 2
    var b: Int = 1
    println(a > b) // true
    println(a >= b) // true
    println(a <= b) // false
    println(a < b) // false
    println("a==b" + (a == b)) // false
    println(a != b) // true
  }
```



**`在Scala中 == 的本质也是equals(),并且 == 还会有非空判断,更推荐使用`**

> **在Scala中,如果要比较对象的内容,则`equals`和`==`都可以**
>
> **如果强调真的要比较地址值,则要用`eq`方法**



#### 1.3 逻辑运算符

> 逻辑运算符指的就是`用来进行逻辑操作的符号`.  可以简单理解为它是: 组合判断. 例如: 判断多个条件是否都满足, 或者满足其中的某一个, 甚至还可以对某个判断结果进行取反操作.

| 运算符 | 功能解释                                                     |
| ------ | ------------------------------------------------------------ |
| &&     | 逻辑与,  要求所有条件都满足(即: 结果为true),  简单记忆: 有false则整体为false. |
| \|\|   | 逻辑或,  要求只要满足任意一个条件即可,  简单记忆: 有true则整体为true. |
| !      | 逻辑非, 用来进行取反操作的. 即: 以前为true, 取反后为false, 以前为false, 取反后为true. |

**注意:**	

1. 逻辑表达式不管简单还是复杂, 最终结果一定是Boolean类型的值, 要么是true, 要么是false.

2. 在Scala代码中, 不能对一个Boolean类型的数据进行**连续取反**操作,  但是在Java中是可以的. 

   > 即:   !!false,  这样写会报错, 不支持这种写法.

**案例**

```scala
//相当于: false && true
println(3 > 5 && 2 < 3)		//结果为: false
//我们可以简写代码为:
//逻辑与: 有false则整体为false.
println(false && true)		//结果为: false
println(true && false)		//结果为: false
println(false && false)		//结果为: false
println(true && true)		//结果为: true

println(false || true)		//结果为: true
println(true || false)		//结果为: true
println(false || false)		//结果为: false
println(true || true)		//结果为: true

println(!false)				//结果为: true
println(!true)				//结果为: false
println(!!true)				//这样写会报错, Scala不支持这种写法, 但是Java代码支持这种写法.
```



#### 1.4 赋值运算符

> 赋值运算符指的就是`用来进行赋值操作的符号`.   例如: 把一个常量值, 或者一个变量值甚至是某一段代码的执行结果赋值给变量, 这些都要用到赋值运算符.

- 基本赋值运算符

  `=`就是基本的赋值运算符,   例如:  var a:Int = 3,  就是把常量值3赋值给变量a

- 扩展赋值运算符

  `+=, -=, *=, /=, %=`

**注意:**

1. 赋值运算符的左边必须是: 变量,  不能是常量.    例如:  3 = 5,   这种写法就是错误的. 

2. 关于扩展赋值运算符, 其实就是把左边的数据和右边的数据进行指定的操作, 然后把结果赋值给左边.

   `例如; a += 3 就是把变量a的值和常量3进行加法操作, 然后把结果赋值给变量a`

3. Scala 中没有++、--操作符，可以通过+=、-=来实现同样的效果

   ```scala
   var r1 = 10
   r1 += 1 // 没有++
   r1 -= 2 // 没有--
   ```

**案例**

```scala
//将常量值1赋值给变量a
var a:Int = 1			//注意: 因为后续代码要修改变量a的值, 所以变量a要用var修饰
//对变量a进行加3操作, 然后把结果重新赋值给变量a
a += 3			//a的最终结果为: a = 4
//对变量a进行减2操作, 然后把结果重新赋值给变量a
a -= 2			//a的最终结果为: a = 2
//对变量a进行乘3操作, 然后把结果重新赋值给变量a
a *= 3			//a的最终结果为: a = 6
//对变量a进行除2操作, 然后把结果重新赋值给变量a
a /= 2			//a的最终结果为: a = 3
//对变量a和2进行取余操作, 然后把结果重新赋值给变量a
a %= 2			//a的最终结果为: a = 1
```



#### 1.5 位运算符Scala 

> 位运算符指的就是`按照位(Bit)来快速操作数据值`, 它只针对于整型数据.  因为计算机底层存储, 操作, 运算采用的都是数据的二进制补码形式, 且以后我们要经常和海量的数据打交道, 为了提高计算效率, 我们就可以使用位运算符来实现快速修改数据值的操作.

> 计算机底层存储, 操作和运算数据, 都是采用`数据的二进制补码形式`来实现的.

| 运算符 | 功能解释                                                     |
| ------ | ------------------------------------------------------------ |
| &      | 按位与,  规则: 有0则0,  都为1则为1.                          |
| \|     | 按位或,  规则: 有1则1,  都为0则为0.                          |
| ^      | 按位异或, 规则: 相同为0, 不同为1.                            |
| ~      | 按位取反, 规则: 0变1, 1变0.                                  |
| <<     | 按位左移, 规则: 每左移一位, 相当于该数据乘2, 例如:  2 << 1, 结果为4 |
| \>>    | 按位右移, 规则: 每右移一位, 相当于该数据除2, 例如:  6 >> 1, 结果为3 |

1. 位运算符只针对于整型数据.
2. 运算符操作的是数据的二进制补码形式.
3. 小技巧: 一个数字被同一个数字位异或两次, 该数字值不变. 即: 10 ^ 20 ^ 20, 结果还是10

**铺垫知识**

- 关于进制

  > 通俗的讲, 逢几进一就是几进制, 例如: 逢二进一就是二进制, 逢十进一就是十进制, 常用的进制有以下几种:

  | 进制名称 | 数据组成规则                                                 | 示例                   |
  | -------- | ------------------------------------------------------------ | ---------------------- |
  | 二进制   | 数据以0b(大小写均可)开头, 由数字0和1组成                     | 0b10001001, 0b00101010 |
  | 八进制   | 数据以0开头, 由数字0~7组成                                   | 064,  011              |
  | 十进制   | 数据直接写即可,  无特殊开头, 由数字0~9组成                   | 10, 20, 333            |
  | 十六进制 | 数据以0x(大小写均可)开头,  由数字0~9, 字母A-F组成(大小写均可) | 0x123F, 0x66ABC        |

  注意:

  关于二进制的数据,  最前边的那一位叫: 符号位, 0表示正数, 1表示负数.  其他位叫: 数值位.

  例如: 0b10001001 结果就是一个: 负数,   0b00101010 结果就是一个:  正数.

- 关于8421码

  8421码就是用来描述`二进制位和十进制数据之间的关系的`, 它可以帮助我们快速的计算数据的二进制或十进制形式.

  8421码对应关系如下:

  **二进制位**				          0	  0  	0	   0	 0	0	0	0		

  **对应的十进制数据**		128	64	32	16	8	4	2	1

  > 1. 计算规则:  二进制位从右往左数, 每多一位, 对应的十进制数据 乘以2.
  > 2. 二进制和十进制相互转换的小技巧: 
  >
  >  *  二进制转十进制:  获取该二进制位对应的十进制数据, 然后累加即可. 
  >    * 例如: 0b101对应的十进制数据计算步骤:  4 + 0 + 1 = 5
  >  * 十进制转二进制:  对十进制数据进行拆解, 看哪些数字相加等于它, 然后标记成二进制即可.
  >    * 例如: 10 对应的二进制数据计算步骤: 10 = 8 + 2  =   0b1010

- 关于整数的原反补码计算规则

  所谓的原反补码, 其实指的都是二进制数据, 把十进制的数据转成其对应的二进制数据, 该二进制数据即为: 原码.

  **注意: 计算机底层存储, 操作和运算数据, 都是采用`数据的二进制补码形式`来实现的.** 

  * 正数
    * 正数的原码, 反码, 补码都一样, 不需要特殊计算.
  * 负数
    * 负数的反码计算规则:  原码的符号位不变, 数值位按位取反(以前为0现在为1, 以前为1现在为0)
    * 负数的补码计算规则:  反码 + 1

**案例**

```scala
//定义两个变量a和b, 初始化值分别为: 3, 5
val a = 3			//二进制数据: 0000 0011
val b = 5			//二进制数据: 0000 0101

//结果为: 0000 0001, 转化成十进制, 结果为: 1
println(a & b)		//打印结果为: 1

//结果为: 0000 0111, 转化成十进制, 结果为: 7
println(a | b)		//打印结果为: 7

//结果为: 0000 0110, 转换成十进制, 结果为: 6
println(a ^ b)		//打印结果为: 6

//计算流程: 1111 1100(补码) -> 1111 1011(反码) -> 1000 0100(原码) -> 十进制数据: -4
println(~ a)		//打印结果为: -4

//计算流程: 1000 0011(-3原码) -> 1111 1100(-3反码) -> 1111 1101(-3补码) -> 0000 0010(取反后新补码) -> 十进制数据: 2
println(~ -3)		//打印结果为: 2

//计算流程: 0000 0011(3的补码) -> 0000 1100(新的补码) -> 十进制数据: 12
println(a << 2)		//打印结果为: 12

//计算流程: 0000 0011(3的补码) -> 0000 0001(新的补码) -> 十进制数据: 1
println(a >> 1)		//打印结果为: 1

println(a ^ b ^ b)	//打印结果为: 3
```



#### 1.6 运算符本质

在 Scala 中其实是没有运算符的，所有运算符都是方法。

1. 当调用对象的方法时，点.可以省略
2. 如果函数参数只有一个，或者没有参数，()可以省略

```scala
def main(args: Array[String]): Unit = {
    // 标准的加法运算
    val i: Int = 1.+(1)
    // （1）当调用对象的方法时，.可以省略
    val j: Int = 1 + (1)
    // （2）如果函数参数只有一个，或者没有参数，()可以省略
    val k: Int = 1 + 1
    println(1.toString())
    println(1 toString())
    println(1 toString)
  }
```



#### 1.7 综合案例: 交换两个变量的值

> 已知有两个Int类型的变量a和b, 初始化值分别为10和20, 请写代码实现变量a和变量b的值的交换.
>
> 即最终结果为: a=20, b=10.  

1. **第一种写法**:通过算数运算符

   ```scala
   //定义两个Int类型的变量a和b, 初始化值分别为10和20
   var a = 10
   var b = 20
   //将变量a和b的计算结果赋值给变量a
   a = a + b	//a = 30, b = 20
   //计算并赋值
   b = a - b	//a = 30, b = 10
   a = a - b	//a = 20, b = 10
   //打印结果
   println("a: " + a)		//a: 20
   println("b: " + b)		//b: 10
   ```

2. **第二种写法**:通过定义临时变量实现

   ```scala
   /定义两个Int类型的变量a和b, 初始化值分别为10和20
   var a = 10
   var b = 20
   //定义临时变量temp, 记录变量a的值
   var temp = a			//a = 10, b = 20, temp = 10
   //把变量b的值赋值给a
   a = b					//a = 20, b = 20, temp = 10
   //把临时变量temp的值赋值给b
   b = temp				//a = 20, b = 10, temp = 10
   //打印结果
   println("a: " + a)		//a: 20
   println("b: " + b)		//b: 10
   ```

3. **通过运算符`^`**

   ```scala
   //定义两个Int类型的变量a和b, 初始化值分别为10和20
   var a = 10
   var b = 20
   //定义临时变量temp, 记录变量a和b的位异或值(这个值不需要我们计算)
   var temp = a ^ b	//即: temp = 10 ^ 20
   //通过位异或进行交换变量值	
   a = a ^ temp		//运算流程: a = a ^ temp = a ^ a ^ b = 10 ^ 10 ^ 20 = 20
   b = b ^ temp		//运算流程: b = b ^ temp = b ^ a ^ b = 20 ^ 10 ^ 20 = 10
   //打印结果
   println("a: " + a)	//a: 20
   println("b: " + b)	//b: 10
   ```

---

### 2.流程控制

在实际开发中, 我们要编写成千上万行代码, 代码的顺序不同, 执行结果肯定也会受到一些影响, 并且有些代码是满足特定条件才能执行的, 有些代码是要重复执行的. 那如何合理规划这些代码呢? 这就需要用到: 流程控制结构了. 

> 示例:下面的代码运行结果是什么
>
> `println(10 + 10 + "Hello,Scala" + 10 + 10)`

这里需要注意:程序的执行顺序是按照我们编写的代码`逐行执行`的

因此上述代码最终打印结果是:`20Hello,scala1010`



#### 2.1 分支控制 if-else 

`if 非常好用的一个功能 If 返回值`

**让程序有选择的的执行，分支控制有三种：单分支、双分支、多分支**

> 判断一位同学的学生成绩等级

- 单分支

  ```scala
  //定义变量, 记录成绩
  val score = 61
  //判断成绩是否不小于60分
  if(score >= 60) {
      println("成绩及格")
  }
  ```

- 双分支

  ```scala
  //定义变量, 记录成绩
  val score = 61
  //判断成绩是否不小于60分
  if(score >= 60) {
      println("成绩及格")
  } else {
      println("成绩不及格")
  }
  ```

- 多分支

  ```scala
  //定义变量, 记录成绩
  val score = 80
  //根据成绩发放对应的奖励
  if(score >= 90 && score <= 100) {
      println("VR设备一套")
  } else if(score >= 80 && score < 90) {
      println("考试卷一套")
  } else if(score >= 0 && score < 80) {
      println("组合拳一套")
  } else {
      println("成绩无效")
  }
  ```

**if语句在使用时, 要注意的事项有以下三点:** 

1. **<strong style="color:#c00000;">和Java一样, 在Scala中, 如果大括号{}内的逻辑代码只有一行, 则大括号可以省略.</strong>** 

2. <strong style="color:#c00000;">在scala中，条件表达式也是有返回值的</strong> 

3. <strong style="color:#c000 

   > eg :定义一个变量sex，再定义一个result变量，如果sex等于"male"，result等于1，否则result等于0

   ```scala
   //定义变量, 表示性别
   val sex = "male"
   //定义变量, 记录if语句的返回值结果
   val result = if(sex == "male") 1 else 0
   //打印结果为 result: 1
   println("result: " + result)
   ```



#### 2.2 嵌套分支

有些时候, 我们会涉及到"组合判断", 即一个分支结构中又嵌套了另一个分支结构, 这种写法就叫嵌套分支. 里边的那个分支结构叫: 内层分支, 外边的那个分支结构叫: 外层分支.

> 注意: 嵌套一般不超过3层. 

**示例**

定义三个变量a,b,c, 初始化值分别为: 10, 20, 30, 通过if分支语句, 获取其中的最大值.

```scala
//定义一个获取最大值的方法 getMax()
def getMax(a: Int, b: Int, c: Int): Int = {
    if (a > b) {
      if (a > c) a else c
    } else {
      if (b > c) b else c
    }
  }
def main(args: Array[String]): Unit = {
    val i = getMax(-10, -20, -40)
    println(i) // -10
  }
```

**扩展: 块表达式**

- scala中，使用`{}`表示一个块表达式
- 和 if 表达式一样，块表达式也是有值的
- 值就是最后一个表达式的值

**示例:**请问以下代码，变量a的值是什么？

```scala
val a = {
   println("1 + 1")
   1 + 1
}
println("a: " + a)
//程序的最终结果为:先打印  1 + 1,然后再打印 a : 2 
```



#### 2.3 Switch 分支结构

在 Scala 中没有 Switch，而是使用模式匹配来处理。

模式匹配涉及到的知识点较为综合，因此放在后面整理。



#### 2.4 For 循环控制

**Scala 也为 for 循环这一常见的控制结构提供了非常多的特性，这些 for 循环的特性被称**

**为 for 推导式或 for 表达式**

1. 范围数据循环（To**）** 

   写法固定: i 作为一个变量, `<-`固定写法 `to`是一个方法 最终的结果是得到一个左右闭合`[1 - 3]`的循环

   ```scala
   for(i <- 1 to 3){
    print(i + " ")
   }
   println()
   ```

2. 范围数据循环（Until**）**

   写法固定: i 作为一个变量, `<-`固定写法 `until是一个方法 最终的结果是得到一个左闭右开`[1 - 3)`的循环

   ```scala
   for(i <- 1 until 3) {
    print(i + " ")
   }
   println()
   ```

3. 循环守卫

   **作用:保护式为 true 则进入循环体内部，为 false 则跳过，类似于 continue。**

   `符合条件则进入循环,否则则跳出循环`

   ```scala
   for(i <- 1 to 3 if i != 2) {
    print(i + " ")
   }
   println()
   ```

   上述代码等价于

   ```scala
   for (i <- 1 to 3){
   	if (i != 2) {
   	print(i + " ")
   	} 
   }
   ```

4. 循环步长

   `by`表示步长

   > 需求：输出 1 到 10 以内的所有奇数

   ```scala
   for (i <- 1 to 10 by 2) {
   	println("i=" + i)
   }
   ```

5. 嵌套循环

   案例 :使用for表达式，打印以下字符, 每次只能输出一个` " * " `,打印三行五列

   ```scala
   //写法一: 普通写法
   for(i <- 1 to 3) {		//外循环控制行数
       for(j <- 1 to 5) {	//内循环控制列数
           print("*")		//每次打印一个*
       }
       println()			//打印完一行(5个*)之后, 记得换行
   }
   
   //写法二: 压缩版
   for(i <- 1 to 3) {		
       //这是两行代码
       for(j <- 1 to 5) if(j == 5) println("*") else print("*")
   }
   
   //写法三: 合并版
   for(i <- 1 to 3; j <- 1 to 5) if(j == 5) println("*") else print("*")
   ```

   通过循环嵌套的方式实现 N * N 的正三角乘法表,这次我们用函数的方式定义

   ```scala
   /**
      * 定义一个打印正三角九九乘法表的函数，通过嵌套循环的方式来实现
      */
   val printMt = (n: Int) => for (i <- 1 to n; j <- 1 to i) print(s"${j} * ${i} = ${j * i}" + (if (i == j) "\r\n" else "\t"))
   ```

6. 引入变量

   基本语法

   ```scala
   for(i <- 1 to 3; j = 4 - i) {
    	println("i=" + i + " j=" + j)
   }
   ```

   说明

   1. for 推导式一行中有多个表达式时，所以要加` ;` 来隔断逻辑

   2. for 推导式有一个不成文的约定：当 for 推导式仅包含单一表达式时使用圆括号，当包含多个表达式时，一般每行一个表达式，并用花括号代替圆括号，如下

      ```scala
      for {
       i <- 1 to 3
       j = 4 - i
      } {
       println("i=" + i + " j=" + j)
      }
      ```

7. 循环返回值

   Scala中的for循环也是有返回值的, 在for循环体中，可以使用yield表达式构建出一个集合(可以简单理解为: 就是一组数据)，我们把使用yield的for表达式称之为**推导式.**

   **示例**:生成一个10、20、30...100的集合

   ```scala
   //for推导式：for表达式中以yield开始，该for表达式会构建出一个集合 
   val ints = for (elem <- 1 to 10) yield elem * 10
   println(ints) // Vector(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
   ```

8. 倒序打印

   说明：如果想倒序打印一组数据，可以用 reverse

   **案例实操：**需求 倒序打印 10 到 1

   ```scala
   for (elem <- 1 to 10 reverse) print(s"${elem} ")
   ```



#### 2.5  While 和 do..While 循环控制

While 和 do..While 的使用和 Java 语言中用法相同

1. While

   **示例**:打印 1 - 10

   ```scala
   //初始化条件
   var i = 1
   //判断条件
   while(i <= 10) {
       //循环体
       println(i)
       //控制条件
       i = i + 1
   }
   ```

2. do..While

   > do.while循环不管判断条件是否成立, 循环体都会执行一次.
   >
   > for循环, while循环都是如果判断条件不成立, 则循环体不执行.

   **需求:打印1-10的数字**

   ```scala
   //初始化条件
   var i = 1
   do{
       //循环体
       println(i)
       //控制条件
       i = i + 1
   }while(i <= 10)	//判断条件
   ```

   

#### 2.6 循环中断

- **<strong style="color:#c00000;">在scala中，类似Java和C++的break/continue关键字被移除了</strong>** 
- <strong style="color:#c00000;">如果一定要使用break/continue，就需要使用scala.util.control包下的Breaks类的**breable**和**break**方法。</strong> 

**具体用法如下**

1. 导包.

   > `import scala.util.control.Breaks._`

2. 使用breakable将for表达式包起来

3. for表达式中需要退出循环的地方，添加`break()`方法调用

**实现break**:使用for表达式打印1-10的数字，如果遇到数字5，则退出for表达式

```scala
  //Java中break的实现写法
    breakable{
      for (elem <- 1 to 10) if (elem == 5) break() else println(elem)
    }
```

**实现continue** 

continue的实现与break类似，但有一点不同：

> 注意:
>
> 1. 实现break是用breakable{}将整个for表达式包起来.
> 2. 而实现continue是用breakable{}将for表达式的循环体包含起来就可以了.

使用for表达式打印1-10的数字，如果遇到数字5，则跳过本次循环

```scala
//在Scala中实现跳出本次循环的需求
    for (elem <- 1 to 10) breakable(if (elem == 5) break() else println(elem))
    println("______________________")
    for (elem <- 1 to 10 if (elem != 6)) println(elem)
```